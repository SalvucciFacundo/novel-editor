# Novel Editor – Cursor Rules

## Stack
- **Framework**: Angular 20+ con SSR
- **Backend/DB**: Firebase (Firestore, Auth, Storage)
- **Estilos**: SCSS con CSS Custom Properties
- **Lenguaje**: TypeScript strict

---

## Angular 20+ – Reglas obligatorias

### Componentes
- SIEMPRE usar `standalone: true`
- SIEMPRE usar `ChangeDetectionStrategy.OnPush`
- SIEMPRE usar `input()` en lugar de `@Input()`
- SIEMPRE usar `output()` en lugar de `@Output()`
- SIEMPRE usar `inject()` en lugar de constructor injection
- SIEMPRE usar `signal()`, `computed()`, `effect()` para estado reactivo

```typescript
// ✅ Correcto
@Component({
  selector: 'app-example',
  standalone: true,
  changeDetection: ChangeDetectionStrategy.OnPush,
  imports: [...],
  template: `...`,
  styleUrl: './example.scss'
})
export class ExampleComponent {
  private service = inject(ExampleService);
  title = input<string>('');
  count = signal(0);
  doubled = computed(() => this.count() * 2);
}

// ❌ Incorrecto
@Component({ selector: 'app-example' })
export class ExampleComponent {
  @Input() title: string = '';
  constructor(private service: ExampleService) {}
}
```

### Control de flujo en templates
- SIEMPRE usar `@if`, `@for`, `@switch` nativos
- NUNCA usar `*ngIf`, `*ngFor`, `*ngSwitch`
- En `@for` SIEMPRE incluir `track`

```html
<!-- ✅ -->
@for (item of items(); track item.id) { <li>{{ item.name }}</li> }
@if (isLoading()) { <app-spinner /> } @else { <app-content /> }

<!-- ❌ -->
<li *ngFor="let item of items">{{ item.name }}</li>
<app-spinner *ngIf="isLoading"></app-spinner>
```

### Servicios
- Decorar con `@Injectable({ providedIn: 'root' })`
- Usar `inject()` para dependencias
- Exponer estado como señales `readonly` con `toSignal()` o `signal()`
- Nunca exponer `BehaviorSubject` directamente; usar `toSignal()`

### Routing
- Usar **lazy loading** con `loadComponent` y `loadChildren`
- Usar **functional guards** (`CanActivateFn`, `CanMatchFn`)
- Leer params de ruta con `inject(ActivatedRoute)` + señales

```typescript
// routes.ts ✅
{
  path: 'novels',
  loadComponent: () => import('./features/novels/novels.component')
    .then(m => m.NovelsComponent),
  canActivate: [authGuard]
}
```

---

## Firebase – Reglas de integración

### Setup en app.config.ts
```typescript
export const appConfig: ApplicationConfig = {
  providers: [
    provideFirebaseApp(() => initializeApp(environment.firebaseConfig)),
    provideFirestore(() => getFirestore()),
    provideAuth(() => getAuth()),
    provideStorage(() => getStorage()),
    provideHttpClient(withFetch()),
  ]
};
```

### Firestore
- Inyectar con `inject(Firestore)`
- Usar `collectionData()` y `docData()` de `@angular/fire/firestore`
- Convertir a señales con `toSignal()`
- Colecciones en `camelCase` plural: `novels`, `chapters`, `users`
- SIEMPRE limitar queries con `limit()` o paginación
- Usar `where()`, `orderBy()` del lado del servidor, no filtrar en cliente

```typescript
@Injectable({ providedIn: 'root' })
export class NovelService {
  private firestore = inject(Firestore);

  novels = toSignal(
    collectionData(collection(this.firestore, 'novels'), { idField: 'id' }) as Observable<Novel[]>,
    { initialValue: [] }
  );

  async create(novel: Omit<Novel, 'id'>): Promise<void> {
    await addDoc(collection(this.firestore, 'novels'), {
      ...novel,
      createdAt: serverTimestamp()
    });
  }
}
```

### Auth
- Inyectar con `inject(Auth)`
- Usar `authState()` de `@angular/fire/auth`
- Guards con `CanActivateFn`
- NUNCA loggear tokens ni datos sensibles

```typescript
// auth.service.ts
@Injectable({ providedIn: 'root' })
export class AuthService {
  private auth = inject(Auth);
  user = toSignal(authState(this.auth));
  isLoggedIn = computed(() => !!this.user());

  async login(email: string, password: string) {
    return signInWithEmailAndPassword(this.auth, email, password);
  }
  async logout() {
    return signOut(this.auth);
  }
}

// auth.guard.ts
export const authGuard: CanActivateFn = () => {
  const auth = inject(AuthService);
  return auth.isLoggedIn() ? true : inject(Router).createUrlTree(['/login']);
};
```

### Storage
- Inyectar con `inject(Storage)`
- Rutas: `users/{uid}/novels/{novelId}/{filename}`
- Validar tipo MIME y tamaño antes de subir
- Mostrar progreso del upload con `uploadBytesResumable`

---

## Diseño – Reglas de UI/UX

### Estilos (SCSS)
- Usar variables CSS (`--color-primary`, `--spacing-md`, etc.) para design tokens
- Mobile-first con breakpoints en mixins SCSS
- `rem` para tipografía y espaciado; `px` solo para bordes
- Nunca usar estilos inline en templates

```scss
// styles/_variables.scss
:root {
  --color-primary: #6366f1;
  --color-bg: #0f0f0f;
  --color-surface: #1a1a1a;
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;
  --spacing-xl: 2rem;
  --font-size-sm: 0.875rem;
  --font-size-md: 1rem;
  --font-size-lg: 1.25rem;
  --radius-md: 0.5rem;
  --radius-lg: 1rem;
}
```

### Accesibilidad
- Atributos ARIA en todos los elementos interactivos
- Contraste mínimo 4.5:1 para texto normal, 3:1 para texto grande
- Navegación completa por teclado con `tabindex` y `(keydown)`
- HTML semántico: `<main>`, `<nav>`, `<article>`, `<section>`, `<header>`

### Patrones de componentes
- Estados explícitos: `loading`, `empty`, `error`, `success`
- Usar `@defer` para componentes pesados del editor
- Animaciones con CSS `@keyframes`, no JavaScript
- Usar `NgOptimizedImage` para imágenes

---

## TypeScript – Reglas
- `strict: true` siempre activo
- Preferir `interface` sobre `type` para objetos
- Nunca usar `any`; usar `unknown` si es necesario
- Documentar con JSDoc funciones complejas
- Inferir tipos cuando sea obvio; anotar parámetros y retornos de funciones públicas

---

## Estructura del proyecto
```
src/app/
  core/
    guards/          # Functional guards
    interceptors/    # HTTP interceptors
    services/        # Servicios singleton (auth, etc.)
  features/
    auth/            # Login, register
    novels/          # Listado y gestión de novelas
    editor/          # Editor de texto enriquecido
    dashboard/       # Panel principal
  shared/
    components/      # Componentes UI reutilizables
    pipes/           # Pipes personalizados
    directives/      # Directivas reutilizables
  models/            # Interfaces TypeScript
environments/
  environment.ts
  environment.prod.ts
```

---

## Convenciones de naming
- Archivos: `kebab-case` (e.g., `novel-editor.component.ts`)
- Clases: `PascalCase` (e.g., `NovelEditorComponent`)
- Variables/funciones: `camelCase` (e.g., `loadNovels()`)
- Constantes: `UPPER_SNAKE_CASE` (e.g., `MAX_CHAPTER_LENGTH`)
- Interfaces: prefijo `I` opcional pero consistente (e.g., `Novel` o `INovel`)
- Señales: sufijo `$` opcional para distinguirlas (e.g., `novels$` o `novels`)
